{"meta":{"title":"Sulin","subtitle":null,"description":"Sulin的个人博客","author":"Sulin","url":"http://sulin2018.github.io","root":"/"},"pages":[{"title":"关于","date":"2018-11-24T09:49:52.000Z","updated":"2021-12-31T08:59:50.840Z","comments":true,"path":"about/index.html","permalink":"http://sulin2018.github.io/about/index.html","excerpt":"","text":"这里是Jackin的个人博客. 博客使用hexo搭建, 文档 主题使用Fan, GitHub 致谢."},{"title":"HelloWorld","date":"2018-11-24T03:39:48.000Z","updated":"2021-12-31T06:13:34.510Z","comments":true,"path":"bak/HelloWorld.html","permalink":"http://sulin2018.github.io/bak/HelloWorld.html","excerpt":"第一篇博客最近打算搭建一个个人博客，先用 Hexo 试试, 本篇是一些文档实验。","text":"第一篇博客最近打算搭建一个个人博客，先用 Hexo 试试, 本篇是一些文档实验。 hexohexo 安装 12345npm install -g hexo-clihexo init &lt;folder&gt;cd &lt;folder&gt;npm install 主要文件及文件夹说明 123_config.yml 配置source/_posts 文章目录themes 主题文件目录 hexo 命令 1234567891011# 创建新文章hexo new name# 生成页面hexo g/generate# 开启本地服务器hexo server# 部署到服务器hexo d/deploy# 清除生成的静态文件缓存hexo clean 一些特殊点 1234567891011分类直接书写不是同级, 而是子级.并列分类：categories:- [Linux]- [Tools]并列+子分类：categories:- [Linux, Hexo]- [Tools, PHP] material-x 主题material-x这是我认为最好看的主题. 12345git clone https://github.com/xaoxuu/hexo-theme-material-x themes/material-xnpm i -S hexo-generator-search hexo-generator-json-content hexo-renderer-less# 配置文件修改themes: material-x MD 测试代码测试 12def test(): print(&#x27;hello python&#x27;) 表格测试 name age a 20 b 30 图片测试 ![DevOps](/images/DevOps.jpg)"},{"title":"dev-git","date":"2020-01-20T11:00:45.000Z","updated":"2021-12-31T06:13:34.510Z","comments":true,"path":"bak/dev-git.html","permalink":"http://sulin2018.github.io/bak/dev-git.html","excerpt":"","text":"gitflow12345678910111213gitflow git initgit-flow feature start main.jsvim main.jsgit add main.jsgit commit -m &quot;add main.js&quot;git-flow feature finish main.jsgit-flow release start v1.0.0git-flow release finish v1.0.0git-flow hotfix start bug001git-flow hotfix finish bug001 git rebase 与 git mergegit rebase 和 git merge 做的事其实是一样的。它们都被设计来将一个分支的更改并入另一个分支，只不过方式有些不同。 merge 的效果是将提交追加到分支, 原分支保留git merge master feature rebase 效果是将提交并入分支, 原分支删除 12git checkout featuregit rebase master ![rebase](/images/dev/git/rebase.png) git rebase 的黄金法则便是，绝不要在公共的分支上使用它。这样做的后果:这次 rebase 将 master 分支上的所有提交都移到了 feature 分支后面。问题是它只发生在你的代码仓库中，其他所有的开发者还在原来的 master 上工作。因为 rebase 引起了新的提交，Git 会认为你的 master 分支和其他人的 master 已经分叉了。"},{"title":"开发 --- svn 使用 命令","date":"2018-12-02T13:46:23.000Z","updated":"2021-12-31T06:13:34.510Z","comments":true,"path":"bak/dev-svn.html","permalink":"http://sulin2018.github.io/bak/dev-svn.html","excerpt":"本篇主要记录 svn 命令。","text":"本篇主要记录 svn 命令。 查看仓库信息1svn info svn 基础命令12345678910111213141516# 检出代码到本地svn checkout path（path是服务器上的目录）# 添加新文件svn add test.php# 提交文件到版本库svn commit -m &quot;LogMessage&quot; [-N] [--no-unlock] PATH(如果选择了保持锁，就使用–no-unlock开关)# 更新代码svn up（默认最新 m版本 path文件）svn update -r m path# 比较（m与n版本比较，默认比较基础版本）svn diff -r m:n path# 查看日志svn log path# 合并a到bsvn merge a b# merge也可以用于代码回滚 比如由10号版本回到8号版本svn merge -r 10:8 ./ 恢复12# 恢复修改，不会恢复被删除目录svn revert 解决冲突1svn resolved 进阶命令1234567891011121314151617181920212223242526# 查看文件状态# ?：不在svn的控制中；M：内容被修改；C：发生冲突；A：预定加入到版本库；K：被锁定svn status path# 第一列保持相同，第二列显示工作版本号，第三和第四列显示最后一次修改的版本号和修改人svn status -v path# 加锁、解锁svn lock/unlock -m &quot;LockMessage&quot; [--force] PATH# 删除svn delete path -m &quot;delete test fle&quot;# 合并差异到当前文件svn merge -r m:n path# 列出版本库文件svn list# 导出svn export -r m# 新建分支svn copy a b -m &#x27;test&#x27;# 更新工作副本至不同的URLsvn switch (sw)"},{"title":"Linux --- shell","date":"2018-11-28T12:13:30.000Z","updated":"2021-12-31T06:13:34.510Z","comments":true,"path":"bak/linux-shell.html","permalink":"http://sulin2018.github.io/bak/linux-shell.html","excerpt":"本篇主要记录 Linux Shell 基础。","text":"本篇主要记录 Linux Shell 基础。 Shell最基本的 shell 是一条条命令构成。 12#!/bin/bashecho &quot;Hello World !&quot; 变量1234567891011121314151617181920212223# 无空格variable=value# 有空格时加引号# 以单引号&#x27; &#x27;包围变量的值时，单引号里面是什么就输出什么，即使内容中有变量和命令（命令需要反引起来）也会把它们原样输出。# 单引号字串中不能出现单引号variable=&#x27;value&#x27;# 以双引号&quot; &quot;包围变量的值时，输出时会先解析里面的变量和命令，而不是把双引号中的变量名和命令原样输出。# 双引号里可以出现转义字符variable=&quot;value&quot;# 命令结果可以给变量赋值variable=`command`variable=$(command)# 只读myUrl=&quot;www.baidu.com&quot;readonly myUrl# 删除unset variable_name# 使用echo $variableecho $&#123;variable&#125; 注意，赋值号的周围不能有空格 给所有变量加上花括号{ }，这是个良好的编程习惯。 特殊变量 1234567$0 当前脚本的文件名$n 传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是$1，第二个参数是$2。$# 传递给脚本或函数的参数个数。$* 传递给脚本或函数的所有参数。$@ 传递给脚本或函数的所有参数。被双引号(&quot; &quot;)包含时，与 $* 稍有不同，下面将会讲到。$? 上个命令的退出状态，或函数的返回值。$$ 当前Shell进程ID。对于 Shell 脚本，就是这些脚本所在的进程ID。 $* 和 $@ 都表示传递给函数或脚本的所有参数，不被双引号(“ “)包含时，都以&quot;$1&quot; &quot;$2&quot; … &quot;$n&quot; 的形式输出所有参数。但是当它们被双引号(“ “)包含时，&quot;$*&quot; 会将所有的参数作为一个整体，以&quot;$1 $2 … $n&quot;的形式输出所有参数；&quot;$@&quot; 会将各个参数分开，以&quot;$1&quot; &quot;$2&quot; … &quot;$n&quot; 的形式输出所有参数。 变量替换 123456$&#123;var&#125; 变量本来的值$&#123;var:-word&#125; 如果变量 var 为空或已被删除(unset)，那么返回 word，但不改变 var 的值。$&#123;var:=word&#125; 如果变量 var 为空或已被删除(unset)，那么返回 word，并将 var 的值设置为 word。$&#123;var:?message&#125; 如果变量 var 为空或已被删除(unset)，那么将消息 message 送到标准错误输出，可以用来检测变量 var 是否可以被正常赋值。若此替换出现在Shell脚本中，那么脚本将停止运行。$&#123;var:+word&#125; 如果变量 var 被定义，那么返回 word，但不改变 var 的值。 运算符原生 bash 不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。 expr 是一款表达式计算工具，使用它能完成表达式的求值操作。 1234567891011# 表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成 2 + 2val=`expr 2 + 2`a=10b=20val=`expr $a + $b`val=`expr $a - $b`# 乘号(*)前边必须加反斜杠(\\)才能实现乘法运算；val=`expr $a \\* $b`val=`expr $b / $a`val=`expr $b % $a` 关系运算：关系运算符只支持数字，不支持字符串，除非字符串的值是数字。 12345678== 相等。用于比较两个数字，相同则返回 true。 [ $a == $b ] 返回 false。!= 不相等。用于比较两个数字，不相同则返回 true。 [ $a != $b ] 返回 true。-eq 检测两个数是否相等，相等返回 true。 [ $a -eq $b ] 返回 true。-ne 检测两个数是否相等，不相等返回 true。 [ $a -ne $b ] 返回 true。-gt 检测左边的数是否大于右边的，如果是，则返回 true。 [ $a -gt $b ] 返回 false。-lt 检测左边的数是否小于右边的，如果是，则返回 true。 [ $a -lt $b ] 返回 true。-ge 检测左边的数是否大等于右边的，如果是，则返回 true。 [ $a -ge $b ] 返回 false。-le 检测左边的数是否小于等于右边的，如果是，则返回 true。 [ $a -le $b ] 返回 true。 布尔运算 123! 非运算，表达式为 true 则返回 false，否则返回 true。 [ ! false ] 返回 true。-o 或运算，有一个表达式为 true 则返回 true。 [ $a -lt 20 -o $b -gt 100 ] 返回 true。-a 与运算，两个表达式都为 true 才返回 true。 [ $a -lt 20 -a $b -gt 100 ] 返回 false。 字符串运算 12345= 检测两个字符串是否相等，相等返回 true。 [ $a = $b ] 返回 false。!= 检测两个字符串是否相等，不相等返回 true。 [ $a != $b ] 返回 true。-z 检测字符串长度是否为0，为0返回 true。 [ -z $a ] 返回 false。-n 检测字符串长度是否为0，不为0返回 true。 [ -z $a ] 返回 true。str 检测字符串是否为空，不为空返回 true。 [ $a ] 返回 true。 文件测试 12345678910111213-b file 检测文件是否是块设备文件，如果是，则返回 true。 [ -b $file ] 返回 false。-c file 检测文件是否是字符设备文件，如果是，则返回 true。 [ -b $file ] 返回 false。-d file 检测文件是否是目录，如果是，则返回 true。 [ -d $file ] 返回 false。-f file 检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。 [ -f $file ] 返回 true。-g file 检测文件是否设置了 SGID 位，如果是，则返回 true。 [ -g $file ] 返回 false。-k file 检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。 [ -k $file ] 返回 false。-p file 检测文件是否是具名管道，如果是，则返回 true。 [ -p $file ] 返回 false。-u file 检测文件是否设置了 SUID 位，如果是，则返回 true。 [ -u $file ] 返回 false。-r file 检测文件是否可读，如果是，则返回 true。 [ -r $file ] 返回 true。-w file 检测文件是否可写，如果是，则返回 true。 [ -w $file ] 返回 true。-x file 检测文件是否可执行，如果是，则返回 true。 [ -x $file ] 返回 true。-s file 检测文件是否为空（文件大小是否大于0），不为空返回 true。 [ -s $file ] 返回 true。-e file 检测文件（包括目录）是否存在，如果是，则返回 true。 [ -e $file ] 返回 true。 字符串操作 12345678910111213141516# 拼接your_name=&quot;qinjx&quot;greeting=&quot;hello, &quot;$your_name&quot; !&quot;greeting_1=&quot;hello, $&#123;your_name&#125; !&quot;# 获取长度string=&quot;abcd&quot;echo $&#123;#string&#125; #输出 4# 提取子串string=&quot;alibaba is a great company&quot;echo $&#123;string:1:4&#125; #输出liba# 查找子串string=&quot;alibaba is a great company&quot;echo `expr index &quot;$string&quot; is` 数组1234567891011121314151617181920# 声明array_name=(value0 value1 value2 value3)array_name[0]=value0array_name[1]=value1array_name[2]=value2# 读取$&#123;array_name[index]&#125;valuen=$&#123;array_name[2]&#125;# 使用@ 或 * 可以获取数组中的所有元素$&#123;array_name[*]&#125;$&#123;array_name[@]&#125;# 取得数组元素的个数length=$&#123;#array_name[@]&#125;# 或者length=$&#123;#array_name[*]&#125;# 取得数组单个元素的长度lengthn=$&#123;#array_name[n]&#125; 可以不使用连续的下标，而且下标的范围没有限制。 printf123456789printf &quot;%d %s\\n&quot; 1 &quot;abc&quot;# 单引号与双引号效果一样printf &#x27;%d %s\\n&#x27; 1 &quot;abc&quot;# 如果没有 arguments，那么 %s 用NULL代替，%d 用 0 代替printf &quot;%s and %d \\n&quot;# 输出 and 0# 格式只指定了一个参数，但多出的参数仍然会按照该格式输出，format-string 被重用printf %s abc def# abcdef 流程语句if 12345678910111213141516171819202122232425262728#!/bin/sha=10b=20if [ $a == $b ]then echo &quot;a is equal to b&quot;elif [ $a -gt $b ]then echo &quot;a is greater than b&quot;elif [ $a -lt $b ]then echo &quot;a is less than b&quot;else echo &quot;None of the condition met&quot;fi# 写成一行if test $[2*3] -eq $[1+5]; then echo &#x27;The two numbers are equal!&#x27;; fi;# test 命令用于检查某个条件是否成立，与方括号([ ])类似。num1=$[2*3]num2=$[1+5]if test $[num1] -eq $[num2]then echo &#x27;The two numbers are equal!&#x27;else echo &#x27;The two numbers are not equal!&#x27;fi test 12345678910111213141516171819202122# 数值-eq 等于则为真-ne 不等于则为真-gt 大于则为真-ge 大于等于则为真-lt 小于则为真-le 小于等于则为真# 字符串= 等于则为真!= 不相等则为真-z 字符串 字符串长度伪则为真-n 字符串 字符串长度不伪则为真# 文件-e 文件名 如果文件存在则为真-r 文件名 如果文件存在且可读则为真-w 文件名 如果文件存在且可写则为真-x 文件名 如果文件存在且可执行则为真-s 文件名 如果文件存在且至少有一个字符则为真-d 文件名 如果文件存在且为目录则为真-f 文件名 如果文件存在且为普通文件则为真-c 文件名 如果文件存在且为字符型特殊文件则为真-b 文件名 如果文件存在且为块特殊文件则为真 case 123456789101112131415echo &#x27;Input a number between 1 to 4&#x27;echo &#x27;Your number is:\\c&#x27;read aNumcase $aNum in 1) echo &#x27;You select 1&#x27; ;; 2) echo &#x27;You select 2&#x27; ;; 3) echo &#x27;You select 3&#x27; ;; 4) echo &#x27;You select 4&#x27; ;; *) echo &#x27;You do not select a number between 1 to 4&#x27; ;;esac 循环for 1234for loop in 1 2 3 4 5do echo &quot;The value is: $loop&quot;done while 123456COUNTER=0while [ $COUNTER -lt 5 ]do COUNTER=&#x27;expr $COUNTER+1&#x27; echo $COUNTERdone until 1234567#!/bin/basha=0until [ ! $a -lt 10 ]do echo $a a=`expr $a + 1`done 跳出循环 break continue 12345678910111213#!/bin/bashwhile :do echo -n &quot;Input a number between 1 to 5: &quot; read aNum case $aNum in 1|2|3|4|5) echo &quot;Your number is $aNum!&quot; ;; *) echo &quot;You do not select a number between 1 to 5, game is over!&quot; break ;; esacdone 函数123456789101112131415#!/bin/bashfunWithReturn()&#123; echo &quot;The function is to get the sum of two numbers...&quot; echo -n &quot;Input first number: &quot; read aNum echo -n &quot;Input another number: &quot; read anotherNum echo &quot;The two numbers are $aNum and $anotherNum !&quot; return $(($aNum+$anotherNum))&#125;# 调用函数只需要给出函数名，不需要加括号funWithReturn# Capture value returnd by last commandret=$?echo &quot;The sum of two numbers is $ret !&quot; 删除函数unset .f function_name 带参数示例 1234567891011#!/bin/bashfunWithParam()&#123; echo &quot;The value of the first parameter is $1 !&quot; # 1 echo &quot;The value of the second parameter is $2 !&quot; # 2 echo &quot;The value of the tenth parameter is $10 !&quot; # 10，这里不是第10个参数，而是第1个加个0 echo &quot;The value of the tenth parameter is $&#123;10&#125; !&quot; # 34 echo &quot;The value of the eleventh parameter is $&#123;11&#125; !&quot; # 73 echo &quot;The amount of the parameters is $# !&quot; # 参数个数 echo &quot;The string of the parameters is $* !&quot; # 传递给函数的所有参数&#125;funWithParam 1 2 3 4 5 6 7 8 9 34 73 包含其他脚本12. filenamesource filename 被包含脚本不需要有执行权限。"},{"title":"network --- 计算机网络 七层模型","date":"2018-11-29T08:53:36.000Z","updated":"2021-12-31T06:13:34.510Z","comments":true,"path":"bak/network-seven-model.html","permalink":"http://sulin2018.github.io/bak/network-seven-model.html","excerpt":"本篇主要记录计算机网络相关知识。","text":"本篇主要记录计算机网络相关知识。 七层模型 应用层：向用户提供具体服务。文件服务、电子邮件：FTP、SMTP、DNS、HTTP 表示层：处理用户信息的表示问题，如编码、数据格式转换和加密解密；LPP 会话层：建立、解除接点联系，向两个实体会话层提供建立和使用连接方法；LDAP、SSL、TLS 传输层：提供可靠端到端的差错和流量控制，保证报文正确传输；TCP、UDP 网络层：通过路由算法为数据包选择合适路由，解决不同网络通信问题；IP 数据链路层：建立和管理节点之间的链路；建立传输链路，传输有地址的数据帧：ARP、RARP 物理层：提供二进制数据物理线路，屏蔽不同介质的物理差异；物理媒体，二进制数据传输：ISO2110、IEEE802 大图概览（图片来源于网络） 物理层核心是实现 bit 数据与物理光电信号转换。 具体功能包括光电信号转换，信号中继放大等。数据的单位称为比特(bit)。 网卡：计算机连接网络的设备。 数据链路层建立相邻结点之间的数据链路。 数据链路层在不可靠的物理介质上提供可靠的传输。该层的作用包括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。数据的单位称为帧(frame)。 MAC 地址：又称计算机的硬件地址, 被固化在适配器(网卡)ROM 上的占 48 位的地址. MAC 地址可以用来唯一区别一台计算机, 因为它在全球是独一无二的 分组交换：由于数据在这次曾要被分割成一个一个的帧, 由于不同的链路规定了不同的最大帧长, 即 MTU(最大传输单元), 凡是超出这个 MTU 的帧都必须被分块. 例如一台货车一次能运输 5 吨的货物, 而有条公路限载重 2 吨, 那么你只好分 3 次运输. 网桥：网桥工作在数据链路层, 根据 MAC 帧的目的地址对收到的帧进行转发和过滤. 以太网交换机：实际上就是一个多接口的网桥, 以太网交换机的每个接口都直接与一个单个主机或另一个集线器相连, 可以很容易实现 VLAN(虚拟局域网) 中继器：增强物理信号，延长网络的设备。 网络层连接独立子网；选择合适的网间路由和交换结点， 确保数据及时传送。 数据的单位称为数据包(packet)。 通过路由选择算法，为报文或分组通过通信子网选择最适当的路径。数据链路层是解决同一网络内节点之间的通信，而网络层主要解决不同子网间的通信。 IP 地址分类： 1234IP地址 = &#123;&lt;网络号&gt;, &lt;主机号&gt;&#125;A类地址 : 0.0.0.0 ~ 127.0.0.0B类地址 : 128.0.0.0 ~ 191.255.0.0C类地址 : 192.0.0.0 ~ 223.255.255.0 划分子网之后的 IP 地址：IP地址 = &#123;&lt;网络号&gt;, &lt;子网号&gt;, &lt;主机号&gt;&#125; 子网掩码：所有的网络都必须使用子网掩码, 同时在路由表中必须有子网掩码这一栏. 如果一个网络不划分子网, 那么该网络的子网掩码就是默认的子网掩码. 123A类地址的默认子网掩码为255.0.0.0B类地址的默认子网掩码为255.255.0.0C类地址的默认子网掩码为255.255.255.0 子网掩码和 IP 地址做按位与运算即可得出网络地址。 ARP 协议：ARP 地址解析协议是解决同一个局域网上的主机或路由器的 IP 地址和 MAC 地址的映射问题, 即 IP 地址 -&gt; ARP -&gt; MAC 地址。当主机 A 欲向本局域网上的某个主机 B 发送 IP 数据报时，就先在其 ARP 高速缓存中查看有无主机 B 的 IP 地址。如果有可以查出其对应的硬件地址，再将此硬件地址写入 MAC 帧，然后通过局域网将该 MAC 帧发往此硬件地址。 RARP 是逆地址解析协议，作用是完成硬件地址到 IP 地址的映射.(请求是广播，应答是单播) 路由器：工作在网络层，是能够连接不同的广域网形成更大的广域网。连接的是异构网络。根据 IP 地址转发。 交换机：工作在数据链路层，是将以太网连接形成更大的以太网，同一个网络。根据 MAC 地址进行转发。 DHCP 协议： 动态主机 IP 配置协议，是一种让系统得以连接到网络上，并获取所需要的配置参数手段。 NAT 协议：网络地址转换属接入广域网(WAN)技术，是一种将私有（保留）地址转化为合法 IP 地址的转换技术。 域名：为了识别主机和组织名称的分层名称。 ICMP：确认 IP 包是否送达目标地址，提供未送达原因，改善网络设置。 传输层提供可靠的端到端的差错控制和流量控制，保证报文的正确传输。 数据单元也称作数据包(packets)。 TCP 的数据单元称为段 (segments)而 UDP 协议的数据单元称为“数据报(datagrams)。 TCP 三次握手(图片来源网络) TCP 四次挥手（图片来源网络) 会话层向两个实体的表示层提供建立和使用连接的方法。 数据传送的单位不再另外命名，而是统称为报文。 表示层处理用户信息的表示问题，如编码、数据格式转换和加密解密”。 应用层直接向用户提供服务，完成用户希望在网络上完成的各种工作。 DNS, Domain Name System：DNS 域名系统 能将域名(例如, www.google.com)解析成 IP 地址. HTTP: 超文本传输协议 每一次 HTTP 请求就需要建立一次 TCP 连接和释放 TCP 连接. HTTP 是无连接, 无状态的. 每一次请求都是作为一次新请求. HTTP/1.0 缺点 : 无连接, 每一次请求都要重新建立 TCP 连接, 所以每一次 HTTP 请求都要花费 2 倍 RTT 时间(一次 TCP 请求, 一次 HTTP 请求) HTTP/1.1 : 使用持续连接, 即保持 TCP 连接一段时间."},{"title":"Python --- excel 读写","date":"2018-11-24T09:27:30.000Z","updated":"2021-12-31T06:13:34.510Z","comments":true,"path":"bak/python-excel.html","permalink":"http://sulin2018.github.io/bak/python-excel.html","excerpt":"本篇主要记录Python的一些常用包和代码.","text":"本篇主要记录Python的一些常用包和代码. CSV读 1234with open(&#x27;read_test.csv&#x27;)as f: f_csv = csv.reader(f) for row in f_csv: print(row) 写 123456789101112with open(&#x27;write_test.csv&#x27;, &#x27;w&#x27;)as f: headers = [&#x27;name&#x27;, &#x27;age&#x27;] datas = [&#x27;jack&#x27;, 20] f_csv = csv.writer(f) f_csv.writerow(headers) f_csv.writerows(datas) # dict 写入 # rows = [&#123;&#x27;name&#x27;: &#x27;jack&#x27;, &#x27;age&#x27;: 20&#125;] # f_csv = csv.DictWriter(f,headers) # f_csv.writeheader() # f_csv.writerows(rows) 读写 Excelxlwt/xlrd如何读写Excel表格文件。 写入 12345678910111213def write_test(): # 1 先创建个工作簿 wbook = xlwt.Workbook(encoding=&quot;utf-8&quot;, style_compression=0) # 2 添加个表 wsheet = wbook.add_sheet(sheetname=&quot;one&quot;) # 3 写入，参数说明：行，列，值 wsheet.write(0, 0, &#x27;姓名&#x27;) wsheet.write(0, 1, &#x27;年龄&#x27;) wsheet.write(1, 0, &#x27;张三&#x27;) wsheet.write(1, 1, &#x27;33&#x27;) # 保存 wbook.save(&#x27;test.xls&#x27;) 读取 12345678def read_test(): # 1 打开excel文件 data = xlrd.open_workbook(&#x27;test.xls&#x27;) # 2 获取第一张工作表（通过索引的方式） table = data.sheets()[0] # 3 遍历打印数据 for row in range(table.nrows): print(table.row_values(row))"},{"title":"Python --- 单例模式 singleton","date":"2018-11-27T11:10:04.000Z","updated":"2021-12-31T06:13:34.510Z","comments":true,"path":"bak/python-singleton.html","permalink":"http://sulin2018.github.io/bak/python-singleton.html","excerpt":"本篇主要记录 Python 单例模式实现。","text":"本篇主要记录 Python 单例模式实现。 在 new 方法中绑定类实例到一个类变量上 12345678910# 方法1：实现__new__方法# 并在将一个类的实例绑定到类变量_instance上,# 如果cls._instance为None说明该类还没有实例化过,实例化该类,并返回# 如果cls._instance不为None,直接返回cls._instanceclass SingleTon(object): def __new__(cls,*args,**kwargs): if not hasattr(cls,&#x27;_instance&#x27;): cls._instance = object.__new__(cls,*args,**kwargs) return cls._instance 使用装饰器(decorator) 12345678910111213141516# 方法2:也是方法1的升级版本# 使用装饰器(decorator),# 这是一种更pythonic,更elegant的方法,# 单例类本身根本不知道自己是单例的,因为他本身(自己的代码)并不是单例的def Single(cls,*args,**kwargs): instances = &#123;&#125; def _singleton(): if cls not in instances: instances[cls] = cls(*args,**kwargs) return instances[cls] return _singleton@Singleclass TestClass(object): a = 1 使用元类(__metaclass__) 1234567891011121314151617# 方法3:本质上是方法1的升级版# 使用__metaclass__（元类）的高级python用法# 一切皆对象，类也是对象，类是元类的实例# type可以创建类：type(类名, 父类的元组（针对继承的情况，可以为空），包含属性的字典（名称和值）)class Single(type): def __init__(self,name,bases,dict): super(Single,self).__init__(name,bases,dict) self._instance = None def __call__(cls,*args,**kw): if cls._instance is None: cls._instance = super(Single,cls).__call__(*args,**kw) return cls._instanceclass Test(object): # 这里表示使用那个元类来创建对象 # python解释器创建类步骤是：当前类有__metaclass__属性，则以此属性对应的元类创建；没有，则从父类找；都没有找到就用type来创建类对象。 __metaclass__ = Single 共享属性 1234567891011# 方法4：共享属性;所谓单例就是所有引用(实例、对象)拥有相同的状态(属性)和行为(方法)# 同一个类的所有实例天然拥有相同的行为(方法),# 只需要保证同一个类的所有实例具有相同的状态(属性)即可# 所有实例共享属性的最简单最直接的方法就是__dict__属性指向(引用)同一个字典(dict)# 同类本身具有相同方法，只要保证产生示例属性指向相同就可以认为是单例。class Single(object): _state = &#123;&#125; def __new__(cls,*args,**kwargs): obj = object.__new__(cls,*args,**kwargs) obj.__dict__ = cls._state return obj"},{"title":"Python --- 装饰器","date":"2019-04-01T04:10:32.000Z","updated":"2021-12-31T06:13:34.510Z","comments":true,"path":"bak/python-wrap.html","permalink":"http://sulin2018.github.io/bak/python-wrap.html","excerpt":"本篇介绍 Python 解释器总结。","text":"本篇介绍 Python 解释器总结。 装饰器装饰器是一个函数,一个用来包装函数的函数，装饰器在函数申明（不需要调用）完成的时候被调用，调用之后返回一个修改之后的函数对象，将其重新赋值原来的标识符，并永久丧失对原始函数对象的访问。 对某个方法应用了装饰方法后， 其实就改变了被装饰函数名称所引用的函数代码块入口点，使其重新指向了由装饰方法所返回的函数入口点。 函数可传递python 中函数可当做参数 12345678def fun_log(func): print(&#x27;&#123;&#125; is run&#x27;.format(func.__name__)) func()def foo(): print(&#x27;i am foo&#x27;)fun_log(foo) 基本装饰器接收函数, 返回也是函数, 就是装饰器 123456789101112def fun_log(func): def wrapper(): print(&#x27;in fun log&#x27;) print(&#x27;&#123;&#125; is run&#x27;.format(func.__name__)) return func() return wrapperdef foo(): print(&#x27;i am foo&#x27;)wrap_fun = fun_log(foo)wrap_fun() 语法糖@123456789101112def fun_log(func): def wrapper(): print(&#x27;in fun log&#x27;) print(&#x27;&#123;&#125; is run&#x27;.format(func.__name__)) return func() return wrapper@fun_logdef foo(): print(&#x27;i am foo&#x27;)foo() 装饰带参函数123456789101112131415def fun_log(func): def wrapper(*args, **kwargs): print(&#x27;in fun log&#x27;) print(&#x27;&#123;&#125; is run&#x27;.format(func.__name__)) print(args) print(kwargs) return func(*args, **kwargs) return wrapper@fun_logdef foo(a, b=123): print(&#x27;i am foo&#x27;) print(a + b)foo(321) 带参数的装饰器123456789101112131415161718def level_log(level): def fun_log(func): def wrapper(*args, **kwargs): if level == &#x27;info&#x27;: print(&#x27;in fun log&#x27;) print(&#x27;&#123;&#125; is run&#x27;.format(func.__name__)) print(args) print(kwargs) return func(*args, **kwargs) return wrapper return fun_log@level_log(&#x27;info&#x27;)def foo(a, b=123): print(&#x27;i am foo&#x27;) print(a + b)foo(321, b=2) functools.wraps使用functools.wraps包装饰避免丢失原函数元信息__name__/__doc__ 123456789101112131415161718192021222324252627import timefrom functools import wrapsdef log_count_run_time(func): @wraps(func) def wrapper(): print(&quot;function runing&quot;) ts = time.time() result = func() te = time.time() print(&quot;function=&#123;0&#125;&quot;.format(func.__name__)) print(&quot;return=&#123;0&#125;&quot;.format(result)) print(&quot;time=%.6f sec&quot; % (te - ts)) return wrapper@log_count_run_timedef sum(): &quot;&quot;&quot;this is sum doc&quot;&quot;&quot; x = 1 y = 2 return x + ysum()# 如果不使用 functools.wraps 装饰的话, 将打印 wrapper Noneprint(sum.__name__)print(sum.__doc__) 类装饰器1234567891011121314class FunLog: def __init__(self, func): self._func = func def __call__(self): print(&#x27;this is funlog class&#x27;) self._func() print(&#x27;func run over&#x27;)@FunLogdef foo(): print(&#x27;this is foo&#x27;)foo() 装饰器顺序12345678910111213141516171819202122232425262728293031323334353637from functools import wrapsdef a(func): @wraps(func) def wrapper(): print(&#x27;this is a&#x27;) return func() return wrapperdef b(func): @wraps(func) def wrapper(): print(&#x27;this is b&#x27;) return func() return wrapperdef c(func): @wraps(func) def wrapper(): print(&#x27;this is c&#x27;) return func() return wrapper@a@b@cdef do_something(): print(&#x27;something&#x27;)do_something()&quot;&quot;&quot;效果类似 f = a(b(c(do_something)))this is athis is bthis is csomething&quot;&quot;&quot;"},{"title":"categories","date":"2021-12-31T09:18:03.000Z","updated":"2021-12-31T09:18:35.940Z","comments":true,"path":"categories/index.html","permalink":"http://sulin2018.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"hexo --- 教程 问题","slug":"hexo","date":"2020-01-20T10:38:46.000Z","updated":"2021-12-31T09:16:31.880Z","comments":true,"path":"2020/01/20/hexo/","link":"","permalink":"http://sulin2018.github.io/2020/01/20/hexo/","excerpt":"博客基于hexo搭建, 这里记录使用方法, 以及使用过程中遇到的一些问题.","text":"博客基于hexo搭建, 这里记录使用方法, 以及使用过程中遇到的一些问题. 基本使用12345678910111213141516171819# 安装sudo npm install -g hexo-cli# 初始化hexo init [folder]hexo new [layout] &lt;title&gt;hexo new page --path about/me &quot;About me&quot;# 本地服务hexo server# 生成博客hexo generatehexo g # -d 立即部署# 部署hexo deployhexo d MD 测试代码测试 12def test(): print(&#x27;hello python&#x27;) 表格测试 name age a 20 b 30 图片测试 ![DevOps](/images/DevOps.jpg) 部署到 Github 文件夹名称大小引起 404 问题原因: 由于 git 命令默认的配置中忽略了文件名的大小写，因此即便文件夹的大小写发生了变更，git 也会表现出置之不理。 解决办法: 修改配置, 使 git 不要忽略大小写. 步骤: 1234567891011121314151617181920212223cd .deploy_git# 修改配置vim .git/config # 修改ignorecase true为false[core]repositoryformatversion = 0filemode = truebare = falselogallrefupdates = trueignorecase = true # 修改true为falseprecomposeunicode = true…# 清除GitHub文件git rm -rf *git commit -m ‘clean all file’git push# 重新部署cd ..hexo cleanhexo g -d","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://sulin2018.github.io/tags/hexo/"}]},{"title":"Linux --- 常用命令","slug":"linux-orders","date":"2019-04-30T02:33:10.000Z","updated":"2021-12-31T08:54:29.170Z","comments":true,"path":"2019/04/30/linux-orders/","link":"","permalink":"http://sulin2018.github.io/2019/04/30/linux-orders/","excerpt":"记录Linux常用命令.","text":"记录Linux常用命令. 包(软件)管理yum 12345678yum search xyum info xyum list xyum install xyum update xyum remove x# 清除缓存yum clean x rpm 12345678910111213141516# 查看程序相关配置rpm -qc x# 程序相关文件rpm -ql x# 已安装包rpm -qa# 详细信息rpm -qi x# 查询文件来源于那个包rpm -qf x# 安装rpm -ivh x.rpm# 升级rpm -Uvh x.rpm# 卸载rpm -e –force x 网络相关123456789101112131415ifconfigifconfig eth0 up/downifconfig eth0 hw ether 00:AA:BB:CC:DD:EE # 修改MAC地址ifconfig eth0 192.168.120.56 netmask 255.255.255.0 broadcast 192.168.120.255 # 配置IP/子网掩码/广播地址route -nroute add/del default gw 192.168.1.1 eth0 # 添加默认路由网关route add/del -host 192.168.1.3 gw 192.168.1.1 dev eth0 # 目标主机route add/del -net 192.168.1.0 netmask 255.255.255.0 dev eth0 # 目标网络route add -net 10.0.0.0 netmask 255.0.0.0 reject # 网络不可达netstat -tnlp # tcp IP展示 listening PIDss -tnlpss -tnp state &#x27;established&#x27; ip 命令 12345678910ip a/addr showip a/addr/address add/del 192.168.78.130/24 dev eth1 # 添加IPip a flush dev eth1ip link sh/show/l/ls/lsit eth1ip link set dev eth1 down/upip r/ro/route sh/showip r/ro/route add/del 192.168.79.0/24 dev eth1ip r/ro/route add/del/chg/change default via 192.168.78.1","categories":[{"name":"Operation","slug":"Operation","permalink":"http://sulin2018.github.io/categories/Operation/"},{"name":"Linux","slug":"Operation/Linux","permalink":"http://sulin2018.github.io/categories/Operation/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://sulin2018.github.io/tags/Linux/"}]}],"categories":[{"name":"Operation","slug":"Operation","permalink":"http://sulin2018.github.io/categories/Operation/"},{"name":"Linux","slug":"Operation/Linux","permalink":"http://sulin2018.github.io/categories/Operation/Linux/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://sulin2018.github.io/tags/hexo/"},{"name":"Linux","slug":"Linux","permalink":"http://sulin2018.github.io/tags/Linux/"}]}